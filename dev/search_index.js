var documenterSearchIndex = {"docs":
[{"location":"integration_test_tool/#Integration-Test-Tool","page":"Integration Test Tool","title":"Integration Test Tool","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"The public API IntegrationTests.jl provides a function called depending_projects(), which returns a vector of package names that depend on the package package_name. In addition to the package name, the function also requires a package name filter package_filter and a project dependency tree project_tree. The project dependency can be constructed from the currently active Julia project environment, which is highly recommended.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"depending_projects(package_name::AbstractString,\n    package_filter::Union{<:AbstractString,Regex},\n    project_tree::AbstractDict)","category":"page"},{"location":"integration_test_tool/#IntegrationTests.depending_projects-Tuple{AbstractString, Union{Regex, AbstractString}, AbstractDict}","page":"Integration Test Tool","title":"IntegrationTests.depending_projects","text":"depending_projects(\n    package_name::AbstractString, \n    package_filter::Union{<:AbstractString,Regex}\n    project_tree::AbstractDict=PkgDependency.builddict(Pkg.project().uuid, Pkg.project())\n) -> Vector{String}\n\nReturns a list of packages that have the package package_name as a dependency. \n\nArguments\n\npackage_name: Name of the dependency\npackage_filter: Ignore all packages that do not match package_filter. This includes the        top node package of the graph. Child nodes are always checked for package_name, but        they are not traversed if they do not match package_filter.\nproject_tree: Project tree in which to search for dependent packages. Each (sub-)package        needs to be AbstractDict{String, AbstractDict}\n\nReturns\n\nA Vector{String} containing the names of all packages that have the given dependency.\n\n\n\n\n\n","category":"method"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"An example for using the depending_projects() function may look as follows:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"julia> using IntegrationTests\n[ Info: Precompiling IntegrationTests [6be7cfa2-1838-408e-bc49-3a824ac3a1fb]\n\njulia> using Pkg\n\njulia> Pkg.activate(\".ci/example_project/MetaTestPkg/\")\n  Activating project at `~/projects/IntegrationTests.jl/.ci/example_project/MetaTestPkg`\n\njulia> depending_projects(\"MyPkgFields\", r\"MyPkg*\")\n2-element Vector{String}:\n \"MyPkgProcesses\"\n \"MyPkgMain\"\n\njulia>","category":"page"},{"location":"integration_test_tool/#Package-Filter","page":"Integration Test Tool","title":"Package Filter","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"The package_filter is a string or a regular expression, which constrains the search space of the dependency graph. All packages and dependencies of packages must match the filter, otherwise they are ignored during searching. For instance, if we set the package filter to r\"^MyPkg*\", the packages MyPkgMain, MyPkgA, MyPkgB, and MyPkgC are traversed in the following diagram. ExternalDep1 and ExternalDep2 are ignored.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgMain -->|using| MyPkgA\n    MyPkgMain -->|using| MyPkgB\n    MyPkgMain -->|using| ExternDep1\n    MyPkgA -->|using| MyPkgC\n    MyPkgA -->|using| ExternDep2","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"The idea behind the package filter is that there are nodes in the dependency graph that can't be changed directly. Let's assume we are the maintainer of all packages starting with MyPkg and the following dependency graph is given:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgMain -->|using| MyPkgA\n    MyPkgMain -->|using| MyPkgB\n    MyPkgMain -->|using| ExternDep1 -->|using| MyPkgA\n    MyPkgA -->|using| MyPkgC\n    MyPkgA -->|using| ExternDep2","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"With the package filter r\"*\", which means traversing all dependencies, the result would be [\"MyPkgMain\", \"ExternDep1\"] if we are searching for MyPkgA. We are not the maintainer of ExternDep1, therefore we can not directly make changes in ExternDep1 and it makes less sense to test ExternDep1 with our code changes.","category":"page"},{"location":"integration_test_tool/#Package-Filter:-Special-Cases","page":"Integration Test Tool","title":"Package Filter: Special Cases","text":"","category":"section"},{"location":"integration_test_tool/#Dependencies-of-non-matching-packages","page":"Integration Test Tool","title":"Dependencies of non matching packages","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"In the following diagram, MyPkgA is not found with the package filter r\"^MyPkg*\", because the traversing algorithm does not traverse ExternDep1. Therefore the dependencies of ExternDep1 are not checked.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgMain -->|using| ExternDep1 -->|using| MyPkgA","category":"page"},{"location":"integration_test_tool/#The-top-graph-package","page":"Integration Test Tool","title":"The top graph package","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"Sometimes the top graph package does not have the same naming scheme as all other packages. The section Project Dependency Tree contains examples of this. If the top package is not included in the package filter, the entire graph is not traversed and the result is empty.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MetaTestPkg -->|using| MyPkgMain -->|using| MyPkgA\n    MyPkgMain -->|using| MyPkgB","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"depending_projects() returns [] for the package filter r\"^MyPkg*\" and the package MyPkgB. The package filter r\"^MyPkg*|^MetaTestPkg$ returns [\"MyPkgA\"].","category":"page"},{"location":"integration_test_tool/#Project-Dependency-Tree","page":"Integration Test Tool","title":"Project Dependency Tree","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"We strongly recommend using a Project.toml of a package from the package ecosystem as input for depending_projects() instead of manually defining the project dependency graph. This is because a manually defined dependency tree can become obsolete. In contrast, the Project.toml must be up to date, otherwise, the Julia application will not work.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"The crucial question is which Project.toml should be used. The dependency graph of a Project.toml can only be constructed in one direction. You can only use the dependencies of the packages. From which package a package is used can only be determined if you came from the package before. Let's assume we have the following package ecosystem:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgMain -->|using| MyPkgA\n    MyPkgMain -->|using| MyPkgB -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgE -->|using| MyPkgF\n    MyPkgMain -->|using| MyPkgC","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"If we take the Project.toml[*] of MyPkgMain, we get the complete graph. If we take the Project.toml of MyPkgB, we get the following graph:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgB -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgE -->|using| MyPkgF","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"note: Note\nThe dependency tree created with the Project.toml of MyPkgMain does not contain MyPkgMain itself. This is a technical detail from Julia. It will contain the dependencies MyPkgA to MyPkgF. To solve the problem, an additional package is needed, which has only the dependency MyPkgMain:Project.tomlname = \"MetaTestPkg\"\nuuid = \"b849e8ad-e76f-4e2e-b89d-52f4e57509ba\"\nauthors = [\"Simeon Ehrig <s.ehrig@hzdr.de>\"]\nversion = \"0.1.0\"\n\n[deps]\nMyPkgMain = \"679daff0-1f79-468a-9a2e-69c3994cafb1\"If we use the Project.toml of MetaTestPkg, we get the complete dependency graph with MyPkgMain.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"note: Note\nTo select a package and create the dependency graph, you need to activate the Julia environment of the package with Pkg.activate(). For example, Pkg.activate(\"path/to/MetaTestPkg\").","category":"page"},{"location":"integration_test_tool/#Project-Dependency-Tree:-Special-cases","page":"Integration Test Tool","title":"Project Dependency Tree: Special cases","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"Let's assume we have the following package ecosystem structure:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MyPkgA -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgE\n    MyPkgC -->|using| MyPkgE\n    MyPkgC -->|using| MyPkgF\n    MyPkgD -->|using| MyPkgG\n    MyPkgD -->|using| MyPkgH\n    MyPkgE -->|using| MyPkgI","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"There is no package we can use to build the entire dependency graph. Therefore, an auxiliary package is required to generate the integration tests for the whole ecosystem:","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"graph TD\n    MetaTestPkg -->|using| MyPkgA\n    MetaTestPkg -->|using| MyPkgB\n    MetaTestPkg -->|using| MyPkgC\n    MyPkgA -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgD\n    MyPkgB -->|using| MyPkgE\n    MyPkgC -->|using| MyPkgE\n    MyPkgC -->|using| MyPkgF\n    MyPkgD -->|using| MyPkgG\n    MyPkgD -->|using| MyPkgH\n    MyPkgE -->|using| MyPkgI","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"If we use the Project.toml of MetaTestPkg, we can construct the entire graph.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"note: Note\nThe \"MetaTestPkg\" does not need to be registered. It can be saved locally in the project repository or created dynamically during the generation of the integration tests.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"","category":"page"},{"location":"api/#References","page":"References","title":"References","text":"","category":"section"},{"location":"api/#Public-API","page":"References","title":"Public API","text":"","category":"section"},{"location":"api/","page":"References","title":"References","text":"Modules = [IntegrationTests]\nPrivate = false","category":"page"},{"location":"api/#IntegrationTests.depending_projects","page":"References","title":"IntegrationTests.depending_projects","text":"depending_projects(\n    package_name::AbstractString, \n    package_filter::Union{<:AbstractString,Regex}\n    project_tree::AbstractDict=PkgDependency.builddict(Pkg.project().uuid, Pkg.project())\n) -> Vector{String}\n\nReturns a list of packages that have the package package_name as a dependency. \n\nArguments\n\npackage_name: Name of the dependency\npackage_filter: Ignore all packages that do not match package_filter. This includes the        top node package of the graph. Child nodes are always checked for package_name, but        they are not traversed if they do not match package_filter.\nproject_tree: Project tree in which to search for dependent packages. Each (sub-)package        needs to be AbstractDict{String, AbstractDict}\n\nReturns\n\nA Vector{String} containing the names of all packages that have the given dependency.\n\n\n\n\n\n","category":"function"},{"location":"api/#IntegrationTests.depending_projects-2","page":"References","title":"IntegrationTests.depending_projects","text":"depending_projects(\n    package_name::AbstractString, \n    package_filter::AbstractVector{<:AbstractString}, \n    project_tree::AbstractDict=PkgDependency.builddict(Pkg.project().uuid, Pkg.project())\n) -> Vector{String}\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-API","page":"References","title":"Internal API","text":"","category":"section"},{"location":"api/","page":"References","title":"References","text":"Modules = [IntegrationTests]\nPublic = false","category":"page"},{"location":"api/#IntegrationTests._match_package_filter-Tuple{AbstractVector{<:AbstractString}, AbstractString}","page":"References","title":"IntegrationTests._match_package_filter","text":"_match_package_filter(\n    package_filter::AbstractVector{<:AbstractString}, \n    package::AbstractString\n)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#IntegrationTests._match_package_filter-Tuple{Union{Regex, AbstractString}, AbstractString}","page":"References","title":"IntegrationTests._match_package_filter","text":"_match_package_filter(\n    package_filter::Union{<:AbstractString,Regex}, \n    package::AbstractString\n)::Bool\n\nCheck if package_filter contains package. Wrapper function for contains() and in().\n\nReturns\n\ntrue if it matches.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntegrationTests._traverse_tree!-Tuple{AbstractString, Union{Regex, AbstractString, AbstractVector{<:AbstractString}}, AbstractDict, AbstractVector{<:AbstractString}, AbstractVector{<:AbstractString}}","page":"References","title":"IntegrationTests._traverse_tree!","text":"_traverse_tree!(\n    package_name::AbstractString, \n    package_filter::Union{<:AbstractString,Regex,AbstractVector{<:AbstractString}}, \n    project_tree::AbstractDict, \n    packages::AbstractVector{<:AbstractString},\n    visited_packages::AbstractVector{<:AbstractString}\n)\n\nTraverse the project tree and add any package to packages that has the package package_name as a dependency.\n\nArguments\n\npackage_name: Name of the dependency\npackage_filter: Ignore all packages that do not match package_filter. This includes the        top node package of the graph. Child nodes always are checked for package_name, but        they are not traveres if they do not match package_filter.\nproject_tree: Project tree, where to search the dependent packages. Each (sub-) package        needs to be AbstractDict{String, AbstractDict}\npackages: Packages which has package_name as dependency.\nvisited_packages: List of packages that are not traveresed again.        Avoids circular, infinite traversing.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"References","title":"References","text":"","category":"page"},{"location":"pipeline_tutorials/#Pipeline-Tutorials","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"","category":"section"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"This section shows how to set up CI tests for different platforms with IntegrationTests.jl. In general, any CI platform can use IntegrationTests.jl if it fulfills a requirement. It must be possible to generate new jobs during the runtime of a CI pipeline depending on the output of a Julia script.","category":"page"},{"location":"pipeline_tutorials/#GitLab-CI","page":"Pipeline Tutorials","title":"GitLab CI","text":"","category":"section"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"Coming soon.","category":"page"},{"location":"pipeline_tutorials/#GitHub-Actions","page":"Pipeline Tutorials","title":"GitHub Actions","text":"","category":"section"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"GitHub provides the matrix mechanism to automatically generate jobs from a given input. Normally, the input is hardcoded as one or more JSON arrays in the Github Actions yaml file. A small workaround allows the input of a JSON array to be generated during the runtime of a Github Actions job. This makes it possible to dynamically create new jobs during the runtime of the CI pipeline.","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"For our example, let's assume that we use a Julia script named generateIntegrationTests.jl that uses IntegrationTests::depending_projects() to generate the integration tests. The GitHub Actions workflow looks like this:","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"name: IntegrationTest\non:\n  push:\n    branches:\n      - main\n      - dev\n    tags: ['*']\n  pull_request:\n  workflow_dispatch:\nconcurrency:\n  # Skip intermediate builds: always.\n  # Cancel intermediate builds: only if it is a pull request build.\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}\njobs:\n    generate:\n        name: Github Action - Generator Integration Jobs\n        runs-on: ubuntu-latest\n        steps:\n        - uses: actions/checkout@v3\n        - uses: julia-actions/setup-julia@v1\n            with:\n            version: 1.9\n            arch: x64\n        - uses: julia-actions/cache@v1\n        - uses: julia-actions/julia-buildpkg@v1\n        - id: set-matrix\n            run: echo \"matrix=$(julia --project=${GITHUB_WORKSPACE} generateIntegrationTests.jl 2> /dev/null)\" >> $GITHUB_OUTPUT\n        outputs:\n            matrix: ${{ steps.set-matrix.outputs.matrix }}\n\n    run-matrix:\n        needs: generate\n        runs-on: ubuntu-latest\n        strategy:\n            matrix:\n                package: ${{ fromJson(needs.generate.outputs.matrix) }}\n        steps:\n            # define the job body of your integration test here depending on the `matrix.package` parameter\n            - run: echo \"run Integration Test for package ${{ matrix.package }}\"","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"The workflow contains two jobs. The first job is the generate job, which generates a list of package names to be tested as an integration test. The run-matrix job is a template that takes a package name and runs an integration test job for the specific package name. Therefore, the run-matrix is executed N times.","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"note: Note\nmatrix: ${{ steps.set-matrix.outputs.matrix }} expects a JSON array. Fortunately, when we print a Julia vector, the output is in the form of a JSON array. Therefore, you can simply use print(depending_projects()) to generate the output of generateIntegrationTests.jl. But be careful not to print any other output, for example, the activation message of Pkg.activate. This output can be redirected to 2> /dev/null for example.","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"Source: https://tomasvotruba.com/blog/2020/11/16/how-to-make-dynamic-matrix-in-github-actions/","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"","category":"page"},{"location":"#IntegrationTests","page":"Home","title":"IntegrationTests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Doc Stable) (Image: Doc Dev) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"⚠️ DISCLAIMER ⚠️","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project moves the project independent part of the integTestGen.jl script to an external project to make it reusable. If we can use this package in our CI of our QED projects, it is ready for Julia registry and can be used by other projects.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"support GitLab CI (version 0.1)\nsupport GitHub Workflows (version 0.2)","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntegrationTests.jl provides tools and instructions for automatically creating integration tests for Julia projects in continuous integration pipelines such as GitLab CI and GitHub Actions.","category":"page"},{"location":"#What-are-integration-tests","page":"Home","title":"What are integration tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integration tests are required if you want to test whether different packages work together after a code change. For example, if package A is used by package B and the API of package A has been changed, the integration test checks whether package B still works.","category":"page"},{"location":"#Example-Project","page":"Home","title":"Example Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our example package eco system contains the two packages PkgA and PkgB. PkgB uses a function from PkgA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"graph TD\n   pkgb(PkgB) -->|using| pkga(PkgA)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgA provides the following function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"module PkgA\n\n    foo(i) = i + 3\n\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgB uses the function of PkgA in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"module PkgB\nusing PkgA\n\n    bar() = PkgA.foo(3)\n\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgB implements a test that checks whether bar() works:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PkgB\nusing Test\n\n@testset \"PkgB.jl\" begin\n    @test PkgB.bar() == 6\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Suppose we change foo(i) = i + 3 to foo(i, j) = i + j + 3. The bar() function in PkgB will no longer work because bar() calls foo() with only one parameter. The integration test will detect the problem and allow the developer to fix the problem before the pull request is merged. For example, a fix can be developed for PkgB that calls foo() with two arguments.","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntegrationTests.jl provides CI configuration files and a tool for the dynamic generation of integration tests for a specific project. The tool determines the dependent packages based on a given Project.toml of the entire package ecosystem. This is possible because a Project.toml of a package describes the dependencies as a graph. The graph can also contain the dependencies of the dependencies. Therefore, you can create a dependency graph of a package ecosystem. A package ecosystem can look like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"graph TD\n   qed(QED.jl) --> base(QEDbase.jl)\n   qed --> processes(QEDprocesses.jl) --> base\n   qed --> fields(QEDfields.jl) --> base\n   processes --> fields\n   qed --> events(QEDevents.jl) --> base","category":"page"},{"location":"","page":"Home","title":"Home","text":"Project.toml of the QED.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if QEDfields.jl is changed, IntegrationTests.jl returns that QED.jl and QEDprocesses.jl are dependent on QEDfields.jl, and we can generate the integration test jobs. Full CI pipeline examples for GitLab CI and GitHub Actions can be found in the Pipeline Tutorials section. For more details on the IntegrationTests.jl tool, see the Integration Test Tool section.","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
