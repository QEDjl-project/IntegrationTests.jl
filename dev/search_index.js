var documenterSearchIndex = {"docs":
[{"location":"integration_test_tool/#Integration-Test-Tool","page":"Integration Test Tool","title":"Integration Test Tool","text":"","category":"section"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"Coming soon.","category":"page"},{"location":"integration_test_tool/","page":"Integration Test Tool","title":"Integration Test Tool","text":"","category":"page"},{"location":"api/#References","page":"References","title":"References","text":"","category":"section"},{"location":"api/#Public-API","page":"References","title":"Public API","text":"","category":"section"},{"location":"api/","page":"References","title":"References","text":"Modules = [IntegrationTests]\nPrivate = false","category":"page"},{"location":"api/#IntegrationTests.depending_projects","page":"References","title":"IntegrationTests.depending_projects","text":"depending_projects(\n    package_name::AbstractString, \n    package_filter::Union{<:AbstractString,Regex}\n    project_tree::AbstractDict=PkgDependency.builddict(Pkg.project().uuid, Pkg.project())\n) -> Vector{String}\n\nReturns a list of packages that have the package package_name as a dependency. \n\nArguments\n\npackage_name: Name of the dependency\npackage_filter: Ignore all packages that do not match package_filter. This includes the        top node package of the graph. Child nodes are always checked for package_name, but        they are not traversed if they do not match package_filter.\nproject_tree: Project tree in which to search for dependent packages. Each (sub-)package        needs to be AbstractDict{String, AbstractDict}\n\nReturns\n\nA Vector{String} containing the names of all packages that have the given dependency.\n\n\n\n\n\n","category":"function"},{"location":"api/#IntegrationTests.depending_projects-2","page":"References","title":"IntegrationTests.depending_projects","text":"depending_projects(\n    package_name::AbstractString, \n    package_filter::AbstractVector{<:AbstractString}, \n    project_tree::AbstractDict=PkgDependency.builddict(Pkg.project().uuid, Pkg.project())\n) -> Vector{String}\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-API","page":"References","title":"Internal API","text":"","category":"section"},{"location":"api/","page":"References","title":"References","text":"Modules = [IntegrationTests]\nPublic = false","category":"page"},{"location":"api/#IntegrationTests._match_package_filter-Tuple{AbstractVector{<:AbstractString}, AbstractString}","page":"References","title":"IntegrationTests._match_package_filter","text":"_match_package_filter(\n    package_filter::AbstractVector{<:AbstractString}, \n    package::AbstractString\n)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#IntegrationTests._match_package_filter-Tuple{Union{Regex, AbstractString}, AbstractString}","page":"References","title":"IntegrationTests._match_package_filter","text":"_match_package_filter(\n    package_filter::Union{<:AbstractString,Regex}, \n    package::AbstractString\n)::Bool\n\nCheck if package_filter contains package. Wrapper function for contains() and in().\n\nReturns\n\ntrue if it matches.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntegrationTests._traverse_tree!-Tuple{AbstractString, Union{Regex, AbstractString, AbstractVector{<:AbstractString}}, AbstractDict, AbstractVector{<:AbstractString}, AbstractVector{<:AbstractString}}","page":"References","title":"IntegrationTests._traverse_tree!","text":"_traverse_tree!(\n    package_name::AbstractString, \n    package_filter::Union{<:AbstractString,Regex,AbstractVector{<:AbstractString}}, \n    project_tree::AbstractDict, \n    packages::AbstractVector{<:AbstractString},\n    visited_packages::AbstractVector{<:AbstractString}\n)\n\nTraverse the project tree and add any package to packages that has the package package_name as a dependency.\n\nArguments\n\npackage_name: Name of the dependency\npackage_filter: Ignore all packages that do not match package_filter. This includes the        top node package of the graph. Child nodes always are checked for package_name, but        they are not traveres if they do not match package_filter.\nproject_tree: Project tree, where to search the dependent packages. Each (sub-) package        needs to be AbstractDict{String, AbstractDict}\npackages: Packages which has package_name as dependency.\nvisited_packages: List of packages that are not traveresed again.        Avoids circular, infinite traversing.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"References","title":"References","text":"","category":"page"},{"location":"pipeline_tutorials/#Pipeline-Tutorials","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"","category":"section"},{"location":"pipeline_tutorials/#GitLab-CI","page":"Pipeline Tutorials","title":"GitLab CI","text":"","category":"section"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"Coming soon.","category":"page"},{"location":"pipeline_tutorials/#GitHub-Actions","page":"Pipeline Tutorials","title":"GitHub Actions","text":"","category":"section"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"Coming soon.","category":"page"},{"location":"pipeline_tutorials/","page":"Pipeline Tutorials","title":"Pipeline Tutorials","text":"","category":"page"},{"location":"#IntegrationTests","page":"Home","title":"IntegrationTests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Doc Stable) (Image: Doc Dev) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"⚠️ DISCLAIMER ⚠️","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project moves the project independent part of the integTestGen.jl script to an external project to make it reusable. If we can use this package in our CI of our QED projects, it is ready for Julia registry and can be used by other projects.","category":"page"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"support GitLab CI (version 0.1)\nsupport GitHub Workflows (version 0.2)","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntegrationTests.jl provides tools and instructions for automatically creating integration tests for Julia projects in continuous integration pipelines such as GitLab CI and GitHub Actions.","category":"page"},{"location":"#What-are-integration-tests","page":"Home","title":"What are integration tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integration tests are required if you want to test whether different packages work together after a code change. For example, if package A is used by package B and the API of package A has been changed, the integration test checks whether package B still works.","category":"page"},{"location":"#Example-Project","page":"Home","title":"Example Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our example package eco system contains the two packages PkgA and PkgB. PkgB uses a function from PkgA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"graph TD\n   pkgb(PkgB) -->|using| pkga(PkgA)","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgA provides the following function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"module PkgA\n\n    foo(i) = i + 3\n\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgB uses the function of PkgA in the following way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"module PkgB\nusing PkgA\n\n    bar() = PkgA.foo(3)\n\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"PkgB implements a test that checks whether bar() works:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PkgB\nusing Test\n\n@testset \"PkgB.jl\" begin\n    @test PkgB.bar() == 6\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Suppose we change foo(i) = i + 3 to foo(i, j) = i + j + 3. The bar() function in PkgB will no longer work because bar() calls foo() with only one parameter. The integration test will detect the problem and allow the developer to fix the problem before the pull request is merged. For example, a fix can be developed for PkgB that calls foo() with two arguments.","category":"page"},{"location":"#Functionality","page":"Home","title":"Functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntegrationTests.jl provides CI configuration files and a tool for the dynamic generation of integration tests for a specific project. The tool determines the dependent packages based on a given Project.toml of the entire package ecosystem. This is possible because a Project.toml of a package describes the dependencies as a graph. The graph can also contain the dependencies of the dependencies. Therefore, you can create a dependency graph of a package ecosystem. A package ecosystem can look like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"graph TD\n   qed(QED.jl) --> base(QEDbase.jl)\n   qed --> processes(QEDprocesses.jl) --> base\n   qed --> fields(QEDfields.jl) --> base\n   processes --> fields\n   qed --> events(QEDevents.jl) --> base","category":"page"},{"location":"","page":"Home","title":"Home","text":"Project.toml of the QED.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, if QEDfields.jl is changed, IntegrationTests.jl returns that QED.jl and QEDprocesses.jl are dependent on QEDfields.jl, and we can generate the integration test jobs. Full CI pipeline examples for GitLab CI and GitHub Actions can be found in the Pipeline Tutorials section. For more details on the IntegrationTests.jl tool, see the Integration Test Tool section.","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
